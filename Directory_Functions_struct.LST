C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/11/2019 17:52:21 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE DIRECTORY_FUNCTIONS_STRUCT
OBJECT MODULE PLACED IN .\Directory_Functions_struct.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE .\Directory_Functions_struct.c DEBUG OBJECTEXTEND

stmt level    source

   1          #include "AT89C51RC2.h"
   2          #include <stdio.h>
   3          #include "main.h"
   4          #include "PORT.H"
   5          #include "UART.h"
   6          #include "SPI.h"
   7          #include "SDCard.h"
   8          #include "File_System.h"
   9          #include "print_bytes.h"
  10          #include "Directory_Functions_struct.h"
  11          #include "Read_Sector.h"
  12          #include <string.h>
  13          
  14          FS_values_t idata Drive_values;
  15          
  16          /***********************************************************************
  17          DESC: Returns a pointer to the global structure Drive_values to export to other files
  18          INPUT: void
  19          RETURNS: Pointer to the structure Drive_values
  20          CAUTION: 
  21          ************************************************************************/
  22          
  23          FS_values_t * Export_Drive_values(void)
  24          {
  25   1         return &Drive_values;
  26   1      }
  27          
  28          
  29          /***********************************************************************
  30          DESC: Prints all short file name entries for a given directory 
  31          INPUT: Starting Sector of the directory and the pointer to a 
  32          block of memory in xdata that can be used to read blocks from the SD card
  33          RETURNS: uint16_t number of entries found in the directory
  34          CAUTION: Supports FAT16, SD_shift must be set before using this function
  35          ************************************************************************/
  36          
  37          
  38          uint8_t read8(uint16_t offset, uint8_t * array_name)
  39          {
  40   1      	uint8_t return_value;
  41   1      	return_value = array_name[offset];
  42   1      	return return_value;
  43   1      
  44   1      }
  45          
  46          uint16_t read16(uint16_t offset, uint8_t * array_name)
  47          {
  48   1      	uint32_t return_value;
  49   1      	uint8_t temp, index;
  50   1      	return_value=0;
  51   1      
  52   1      	for(index=0;index<2;index++)
  53   1      	{
  54   2      		temp=*(array_name+offset+(1-index));
  55   2      		return_value=return_value<<8;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/11/2019 17:52:21 PAGE 2   

  56   2      		return_value|=temp;
  57   2      	}
  58   1      	return return_value;
  59   1      }
  60          
  61          uint32_t read32(uint16_t offset, uint8_t * array_name)
  62          {
  63   1      	uint32_t return_value;
  64   1      	uint8_t temp, index;
  65   1      	return_value=0;
  66   1      
  67   1      	for(index=0;index<4;index++)
  68   1      	{
  69   2      		temp=*(array_name+offset+(3-index));
  70   2      		return_value=return_value<<8;
  71   2      		return_value|=temp;
  72   2      	}
  73   1      	return return_value;
  74   1      }
  75          
  76          /*
  77          uint16_t  Print_Directory(uint32_t Sector_num, uint8_t xdata * array_in)
  78          { 
  79             uint32_t Sector, max_sectors;
  80             uint16_t i, entries;
  81             uint8_t temp8, j, attr, out_val, error_flag;
  82             uint8_t * values;
  83          
  84          
  85             values=array_in;
  86             entries=0;
  87             i=0;
  88             if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
  89             { 
  90                max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
  91             }
  92             else
  93             {
  94                max_sectors=Drive_values.SecPerClus;
  95             }
  96             Sector=Sector_num;
  97             error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
  98             if(error_flag==no_errors)
  99             {
 100               do
 101               {
 102                  temp8=read8(0+i,values);  // read first byte to see if empty
 103                  if((temp8!=0xE5)&&(temp8!=0x00))
 104          	    {  
 105          	       attr=read8(0x0b+i,values);
 106          		   if((attr&0x0E)==0)   // if hidden, system or Vol_ID bit is set do not print
 107          		   {
 108          		      entries++;
 109          			  printf("%5d. ",entries);  // print entry number with a fixed width specifier
 110          		      for(j=0;j<8;j++)
 111          			  {
 112          			     out_val=read8(i+j,values);   // print the 8 byte name
 113          			     putchar(out_val);
 114          			  }
 115                        if((attr&0x10)==0x10)  // indicates directory
 116          			  {
 117          			     for(j=8;j<11;j++)
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/11/2019 17:52:21 PAGE 3   

 118          			     {
 119          			        out_val=read8(i+j,values);
 120          			        putchar(out_val);
 121          			     }
 122          			     printf("[DIR]\n");
 123          			  }
 124          			  else       // print a period and the three byte extension for a file
 125          			  {
 126          			     putchar(0x2E);       
 127          			     for(j=8;j<11;j++)
 128          			     {
 129          			        out_val=read8(i+j,values);
 130          			        putchar(out_val);
 131          			     }
 132          			     putchar(0x0d);
 133                           putchar(0x0a);
 134          			  }
 135          		    }
 136          		}
 137          		    i=i+32;  // next entry
 138          		    if(i>510)
 139          		    {
 140          			  Sector++;
 141                        if((Sector-Sector_num)<max_sectors)
 142          			  {
 143                           error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 144          			     if(error_flag!=no_errors)
 145          			     {
 146          			        entries=0;   // no entries found indicates disk read error
 147          				    temp8=0;     // forces a function exit
 148          			     }
 149                           i=0;
 150          			  }
 151          			  else
 152          			  {
 153          			     entries=entries|more_entries;  // set msb to indicate more entries in another cluster
 154          			     temp8=0;                       // forces a function exit
 155          			  }
 156          		    }
 157                   
 158          	  }while(temp8!=0);
 159          	}
 160          	else
 161          	{
 162          	   entries=0;    // no entries found indicates disk read error
 163          	}
 164             return entries;
 165           }
 166          */
 167          
 168          /***********************************************************************
 169          DESC: Uses the same method as Print_Directory to locate short file names,
 170                but locates a specified entry and returns and cluster  
 171          INPUT: Starting Sector of the directory, an entry number and a pointer to a 
 172          block of memory in xdata that can be used to read blocks from the SD card
 173          RETURNS: uint32_t with cluster in lower 28 bits.  Bit 28 set if this is 
 174                   a directory entry, clear for a file.  Bit 31 set for error.
 175          CAUTION: 
 176          ************************************************************************/
 177          /*
 178          uint32_t Read_Dir_Entry(uint32_t Sector_num, uint16_t Entry, uint8_t xdata * array_in)
 179          { 
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/11/2019 17:52:21 PAGE 4   

 180             uint32_t Sector, max_sectors, return_clus;
 181             uint16_t i, entries;
 182             uint8_t temp8, attr, error_flag;
 183             uint8_t * values;
 184          
 185             values=array_in;
 186             entries=0;
 187             i=0;
 188             return_clus=0;
 189             if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 190             { 
 191                max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 192             }
 193             else
 194             {
 195                max_sectors=Drive_values.SecPerClus;
 196             }
 197             Sector=Sector_num;
 198             error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 199             if(error_flag==no_errors)
 200             {
 201               do
 202               {
 203                  temp8=read8(0+i,values);  // read first byte to see if empty
 204                  if((temp8!=0xE5)&&(temp8!=0x00))
 205          	    {  
 206          	       attr=read8(0x0b+i,values);
 207          		   if((attr&0x0E)==0)    // if hidden do not print
 208          		   {
 209          		      entries++;
 210                        if(entries==Entry)
 211                        {
 212          			    if(Drive_values.FATtype==FAT32)
 213                          {
 214                             return_clus=read8(21+i,values);
 215          				   return_clus=return_clus<<8;
 216                             return_clus|=read8(20+i,values);
 217                             return_clus=return_clus<<8;
 218                          }
 219                          return_clus|=read8(27+i,values);
 220          			    return_clus=return_clus<<8;
 221                          return_clus|=read8(26+i,values);
 222          			    attr=read8(0x0b+i,values);
 223          			    if(attr&0x10) return_clus|=directory_bit;
 224                          temp8=0;    // forces a function exit
 225                        }
 226                        
 227          		    }
 228          		}
 229          		    i=i+32;  // next entry
 230          		    if(i>510)
 231          		    {
 232          			  Sector++;
 233          			  if((Sector-Sector_num)<max_sectors)
 234          			  {
 235                           error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 236          			     if(error_flag!=no_errors)
 237          			     {
 238          			         return_clus=no_entry_found;
 239                               temp8=0; 
 240          			     }
 241          			     i=0;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/11/2019 17:52:21 PAGE 5   

 242          			  }
 243          			  else
 244          			  {
 245          			     temp8=0;                       // forces a function exit
 246          			  }
 247          		    }
 248                   
 249          	  }while(temp8!=0);
 250          	}
 251          	else
 252          	{
 253          	   return_clus=no_entry_found;
 254          	}
 255          	if(return_clus==0) return_clus=no_entry_found;
 256             return return_clus;
 257           }
 258          */
 259          /*
 260          typedef struct
 261          {
 262            uint8_t SecPerClus;
 263            uint8_t FATtype;
 264            uint8_t BytesPerSecShift;
 265            uint8_t FATshift;
 266            uint16_t BytesPerSec;
 267            uint32_t FirstRootDirSec;
 268            uint32_t FirstDataSec;
 269            uint32_t StartofFAT;
 270            uint32_t RootDirSecs;
 271          } FS_values_t;
 272          */
 273          uint8_t Mount_Drive(uint8_t xdata * array_name)
 274          {
 275   1      	uint8_t i;
 276   1      	uint8_t temp_8;
 277   1      	uint32_t temp_32;
 278   1      	uint8_t error_flag;
 279   1      	uint16_t RsvdSectorCount;
 280   1      	uint8_t NumFATS;
 281   1      	uint16_t RootEntryCnt;
 282   1      	uint16_t TotalSectors16;
 283   1      	uint16_t FATsz16;
 284   1      	uint32_t TotalSectors32;
 285   1      	uint32_t FATsz32;
 286   1      	uint32_t RootCluster;
 287   1      	uint8_t RelativeSectors;
 288   1      	
 289   1      	// Read in BPB or MBR
 290   1      	error_flag = Read_Sector(0, 512, array_name);
 291   1      	// Check for BPB or MBR
 292   1      	temp_8 = read8(0,array_name);	
 293   1      	printf("Debug:: Offset 0 of Sector 0 is %x\r\n",temp_8);
 294   1      	if((temp_8!=0xEB)&&(temp_8!=0xE9))
 295   1      	{
 296   2      		temp_32 = read32(0x01C6,array_name);
 297   2      		printf("Debug:: Offset 0x01c6 of Sector 0 is %lx \r\n",temp_32);
 298   2      		error_flag = Read_Sector(temp_32,512,array_name);
 299   2      		RelativeSectors = read8(0,array_name);
 300   2      		printf("Debug:: Offset 0 of Relative Sectors is %x\r\n",RelativeSectors);
 301   2      		if((temp_8!=0xEB)&&(temp_8!=0xE9))
 302   2      		{
 303   3      			printf("Error BPB not Found!\r\n");
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/11/2019 17:52:21 PAGE 6   

 304   3      		}
 305   2      		else
 306   2      		{
 307   3      			printf("BPB Found!\r\n");
 308   3      		}
 309   2      	}
 310   1      	// Determine FAT type
 311   1      	Drive_values.BytesPerSec = read16(0x0B,array_name);
 312   1      	printf("BytesPerSec:: %x\r\n",Drive_values.BytesPerSec);
 313   1      	Drive_values.SecPerClus = read8(0x0D,array_name);
 314   1      	printf("SecPerClus:: %bx\r\n",Drive_values.SecPerClus);
 315   1      	RsvdSectorCount = read16(0x0E,array_name);
 316   1      	printf("RsvdSectorCount:: %x\r\n",RsvdSectorCount);
 317   1      	NumFATS = read8(0x10,array_name);
 318   1      	printf("NumFATS:: %bx\r\n",NumFATS);
 319   1      	RootEntryCnt = read16(0x11,array_name);
 320   1      	printf("RootEntryCnt:: %x\r\n",RootEntryCnt);
 321   1      	TotalSectors16 = read16(0x13,array_name);
 322   1      	printf("TotalSectors16:: %x\r\n",TotalSectors16);
 323   1      	FATsz16 = read16(0x16,array_name);
 324   1      	printf("FATsz16:: %x\r\n",FATsz16);
 325   1      	TotalSectors32 = read32(0x20,array_name);
 326   1      	printf("TotalSectors32:: %lx\r\n",TotalSectors32);
 327   1      	FATsz32 = read32(0x24,array_name);
 328   1      	printf("FATsz32:: %lx\r\n",FATsz32);
 329   1      	RootCluster = read32(0x2C, array_name);
 330   1      	printf("RootCluster:: %lx\r\n",RootCluster);
 331   1      	Drive_values.StartofFAT = RsvdSectorCount + RelativeSectors;
 332   1      	printf("StartofFAT:: %lx\r\n",Drive_values.StartofFAT);
 333   1      	Drive_values.RootDirSecs = ((RootEntryCnt*32) + (Drive_values.BytesPerSec-1))/Drive_values.BytesPerSec;
 334   1      	printf("RootDirSecs:: %lx\r\n",Drive_values.RootDirSecs);
 335   1      	Drive_values.FirstDataSec = RsvdSectorCount + (NumFATS*FATsz32) + Drive_values.RootDirSecs;
 336   1      	printf("FirstDataSec:: %lx\r\n",Drive_values.FirstDataSec);
 337   1      	Drive_values.FirstRootDirSec = ((RootCluster-2)*Drive_values.SecPerClus)+Drive_values.FirstDataSec;
 338   1      	printf("FirstRootDirSec:: %lx\r\n",Drive_values.FirstRootDirSec);
 339   1      
 340   1      	return error_flag;
 341   1      }
*** WARNING C280 IN LINE 275 OF .\DIRECTORY_FUNCTIONS_STRUCT.C: 'i': unreferenced local variable
 342          
 343          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1013    ----
   CONSTANT SIZE    =    439    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      43
   IDATA SIZE       =     22    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
