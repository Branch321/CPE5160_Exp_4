C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/12/2019 13:08:19 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE DIRECTORY_FUNCTIONS_STRUCT
OBJECT MODULE PLACED IN .\Directory_Functions_struct.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE .\Directory_Functions_struct.c DEBUG OBJECTEXTEND

stmt level    source

   1          #include "AT89C51RC2.h"
   2          #include <stdio.h>
   3          #include "main.h"
   4          #include "PORT.H"
   5          #include "UART.h"
   6          #include "SPI.h"
   7          #include "SDCard.h"
   8          #include "File_System.h"
   9          #include "print_bytes.h"
  10          #include "Directory_Functions_struct.h"
  11          #include "Read_Sector.h"
  12          #include <string.h>
  13          #include "print_bytes.h"
  14          
  15          FS_values_t idata Drive_values;
  16          
  17          /***********************************************************************
  18          DESC: Returns a pointer to the global structure Drive_values to export to other files
  19          INPUT: void
  20          RETURNS: Pointer to the structure Drive_values
  21          CAUTION: 
  22          ************************************************************************/
  23          
  24          FS_values_t * Export_Drive_values(void)
  25          {
  26   1         return &Drive_values;
  27   1      }
  28          
  29          uint8_t read8(uint16_t offset, uint8_t * array_name)
  30          {
  31   1      	uint8_t return_value;
  32   1      	return_value = array_name[offset];
  33   1      	return return_value;
  34   1      
  35   1      }
  36          
  37          uint16_t read16(uint16_t offset, uint8_t * array_name)
  38          {
  39   1      	uint32_t return_value;
  40   1      	uint8_t temp, index;
  41   1      	return_value=0;
  42   1      
  43   1      	for(index=0;index<2;index++)
  44   1      	{
  45   2      		temp=*(array_name+offset+(1-index));
  46   2      		return_value=return_value<<8;
  47   2      		return_value|=temp;
  48   2      	}
  49   1      	return return_value;
  50   1      }
  51          
  52          uint32_t read32(uint16_t offset, uint8_t * array_name)
  53          {
  54   1      	uint32_t return_value;
  55   1      	uint8_t temp, index;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/12/2019 13:08:19 PAGE 2   

  56   1      	return_value=0;
  57   1      
  58   1      	for(index=0;index<4;index++)
  59   1      	{
  60   2      		temp=*(array_name+offset+(3-index));
  61   2      		return_value=return_value<<8;
  62   2      		return_value|=temp;
  63   2      	}
  64   1      	return return_value;
  65   1      }
  66          
  67          /***********************************************************************
  68          DESC: Prints all short file name entries for a given directory
  69          INPUT: Starting Sector of the directory and the pointer to a
  70          block of memory in xdata that can be used to read blocks from the SD card
  71          RETURNS: uint16_t number of entries found in the directory
  72          CAUTION: Supports FAT16, SD_shift must be set before using this function
  73          ************************************************************************/
  74          
  75          uint16_t  Print_Directory(uint32_t Sector_num, uint8_t xdata * array_in)
  76          { 
  77   1         uint32_t Sector, max_sectors;
  78   1         uint16_t i, entries;
  79   1         uint8_t temp8, j, attr, out_val, error_flag;
  80   1         uint8_t * values;
  81   1      
  82   1      
  83   1         values=array_in;
  84   1         entries=0;
  85   1         i=0;
  86   1         if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
  87   1         { 
  88   2            max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
  89   2         }
  90   1         else
  91   1         {
  92   2            max_sectors=Drive_values.SecPerClus;
  93   2         }
  94   1         Sector=Sector_num;
  95   1         error_flag=Read_Sector(Sector, Drive_values.BytesPerSec, values);
  96   1         //print_memory(values, Drive_values.BytesPerSec);
  97   1         if(error_flag==no_errors)
  98   1         {
  99   2           do
 100   2           {
 101   3              temp8=read8(0+i,values);  // read first byte to see if empty
 102   3              if((temp8!=0xE5)&&(temp8!=0x00))
 103   3      	    {  
 104   4      	       attr=read8(0x0b+i,values);
 105   4      		   if((attr&0x0E)==0)   // if hidden, system or Vol_ID bit is set do not print
 106   4      		   {
 107   5      		      entries++;
 108   5      			  printf("%5d. ",entries);  // print entry number with a fixed width specifier
 109   5      		      for(j=0;j<8;j++)
 110   5      			  {
 111   6      			     out_val=read8(i+j,values);   // print the 8 byte name
 112   6      			     putchar(out_val);
 113   6      			  }
 114   5                    if((attr&0x10)==0x10)  // indicates directory
 115   5      			  {
 116   6      			     for(j=8;j<11;j++)
 117   6      			     {
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/12/2019 13:08:19 PAGE 3   

 118   7      			        out_val=read8(i+j,values);
 119   7      			        putchar(out_val);
 120   7      			     }
 121   6      			     printf("[DIR]\n");
 122   6      			  }
 123   5      			  else       // print a period and the three byte extension for a file
 124   5      			  {
 125   6      			     putchar(0x2E);       
 126   6      			     for(j=8;j<11;j++)
 127   6      			     {
 128   7      			        out_val=read8(i+j,values);
 129   7      			        putchar(out_val);
 130   7      			     }
 131   6      			     putchar(0x0d);
 132   6                       putchar(0x0a);
 133   6      			  }
 134   5      		    }
 135   4      		}
 136   3      		    i=i+32;  // next entry
 137   3      		    if(i>510)
 138   3      		    {
 139   4      			  Sector++;
 140   4                    if((Sector-Sector_num)<max_sectors)
 141   4      			  {
 142   5                       error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 143   5      				 //print_memory(values, Drive_values.BytesPerSec);
 144   5      			     if(error_flag!=no_errors)
 145   5      			     {
 146   6      			        entries=0;   // no entries found indicates disk read error
 147   6      				    temp8=0;     // forces a function exit
 148   6      			     }
 149   5                       i=0;
 150   5      			  }
 151   4      			  else
 152   4      			  {
 153   5      			     entries=entries|more_entries;  // set msb to indicate more entries in another cluster
 154   5      			     temp8=0;                       // forces a function exit
 155   5      			  }
 156   4      		    }
 157   3               
 158   3      	  }while(temp8!=0);
 159   2      	}
 160   1      	else
 161   1      	{
 162   2      		printf("Error has occured");
 163   2      	   entries=0;    // no entries found indicates disk read error
 164   2      	}
 165   1         return entries;
 166   1       }
 167          
 168          
 169          /***********************************************************************
 170          DESC: Uses the same method as Print_Directory to locate short file names,
 171                but locates a specified entry and returns and cluster  
 172          INPUT: Starting Sector of the directory, an entry number and a pointer to a 
 173          block of memory in xdata that can be used to read blocks from the SD card
 174          RETURNS: uint32_t with cluster in lower 28 bits.  Bit 28 set if this is 
 175                   a directory entry, clear for a file.  Bit 31 set for error.
 176          CAUTION: 
 177          ************************************************************************/
 178          /*
 179          uint32_t Read_Dir_Entry(uint32_t Sector_num, uint16_t Entry, uint8_t xdata * array_in)
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/12/2019 13:08:19 PAGE 4   

 180          { 
 181             uint32_t Sector, max_sectors, return_clus;
 182             uint16_t i, entries;
 183             uint8_t temp8, attr, error_flag;
 184             uint8_t * values;
 185          
 186             values=array_in;
 187             entries=0;
 188             i=0;
 189             return_clus=0;
 190             if (Drive_values.FATtype==FAT16)  // included for FAT16 compatibility
 191             { 
 192                max_sectors=Drive_values.RootDirSecs;   // maximum sectors in a FAT16 root directory
 193             }
 194             else
 195             {
 196                max_sectors=Drive_values.SecPerClus;
 197             }
 198             Sector=Sector_num;
 199             error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 200             if(error_flag==no_errors)
 201             {
 202               do
 203               {
 204                  temp8=read8(0+i,values);  // read first byte to see if empty
 205                  if((temp8!=0xE5)&&(temp8!=0x00))
 206          	    {  
 207          	       attr=read8(0x0b+i,values);
 208          		   if((attr&0x0E)==0)    // if hidden do not print
 209          		   {
 210          		      entries++;
 211                        if(entries==Entry)
 212                        {
 213          			    if(Drive_values.FATtype==FAT32)
 214                          {
 215                             return_clus=read8(21+i,values);
 216          				   return_clus=return_clus<<8;
 217                             return_clus|=read8(20+i,values);
 218                             return_clus=return_clus<<8;
 219                          }
 220                          return_clus|=read8(27+i,values);
 221          			    return_clus=return_clus<<8;
 222                          return_clus|=read8(26+i,values);
 223          			    attr=read8(0x0b+i,values);
 224          			    if(attr&0x10) return_clus|=directory_bit;
 225                          temp8=0;    // forces a function exit
 226                        }
 227                        
 228          		    }
 229          		}
 230          		    i=i+32;  // next entry
 231          		    if(i>510)
 232          		    {
 233          			  Sector++;
 234          			  if((Sector-Sector_num)<max_sectors)
 235          			  {
 236                           error_flag=Read_Sector(Sector,Drive_values.BytesPerSec,values);
 237          			     if(error_flag!=no_errors)
 238          			     {
 239          			         return_clus=no_entry_found;
 240                               temp8=0; 
 241          			     }
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/12/2019 13:08:19 PAGE 5   

 242          			     i=0;
 243          			  }
 244          			  else
 245          			  {
 246          			     temp8=0;                       // forces a function exit
 247          			  }
 248          		    }
 249                   
 250          	  }while(temp8!=0);
 251          	}
 252          	else
 253          	{
 254          	   return_clus=no_entry_found;
 255          	}
 256          	if(return_clus==0) return_clus=no_entry_found;
 257             return return_clus;
 258           }
 259          */
 260          /*
 261          typedef struct
 262          {
 263            uint8_t SecPerClus;
 264            uint8_t FATtype;
 265            uint8_t BytesPerSecShift;
 266            uint8_t FATshift;
 267            uint16_t BytesPerSec;
 268            uint32_t FirstRootDirSec;
 269            uint32_t FirstDataSec;
 270            uint32_t StartofFAT;
 271            uint32_t RootDirSecs;
 272          } FS_values_t;
 273          */
 274          uint8_t Mount_Drive(uint8_t xdata * array_name)
 275          {
 276   1      	uint8_t i;
 277   1      	uint8_t temp_8;
 278   1      	//uint32_t temp_32;
 279   1      	uint8_t error_flag;
 280   1      	uint16_t RsvdSectorCount;
 281   1      	uint8_t NumFATS;
 282   1      	uint16_t RootEntryCnt;
 283   1      	uint16_t TotalSectors16;
 284   1      	uint16_t FATsz16;
 285   1      	uint32_t TotalSectors32;
 286   1      	uint32_t FATsz32;
 287   1      	uint32_t RootCluster;
 288   1      	uint32_t RelativeSectors;
 289   1      	
 290   1      	// Read in BPB or MBR
 291   1      	error_flag = Read_Sector(0, 512, array_name);
 292   1      	//print_memory(array_name, 512);
 293   1      	// Check for BPB or MBR
 294   1      	temp_8 = read8(0,array_name);
 295   1      	printf("Debug:: Offset 0 of Sector 0 is %x\r\n",temp_8);
 296   1      	if((temp_8!=0xEB)&&(temp_8!=0xE9))
 297   1      	{
 298   2      		printf("Found MBR...\r\n");
 299   2      		RelativeSectors = read32(0x01C6,array_name);
 300   2      		printf("Debug:: Offset 0 of Relative Sectors is %lx\r\n",RelativeSectors);
 301   2      		error_flag = Read_Sector(RelativeSectors ,512,array_name);
 302   2      		temp_8 = read8(0,array_name);
 303   2      		printf("Debug:: temp8 is %x\r\n",temp_8);
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/12/2019 13:08:19 PAGE 6   

 304   2      		if((temp_8!=0xEB)&&(temp_8!=0xE9))
 305   2      		{
 306   3      			printf("Error BPB not Found!\r\n");
 307   3      		}
 308   2      		else
 309   2      		{
 310   3      			printf("BPB Found!\r\n");
 311   3      		}
 312   2      	}
 313   1      	// Determine FAT type
 314   1      	print_memory(array_name, 512);
 315   1      	Drive_values.BytesPerSec = read16(0x0B,array_name);
 316   1      	printf("BytesPerSec:: %x\r\n",Drive_values.BytesPerSec);
 317   1      
 318   1      	Drive_values.SecPerClus = read8(0x0D,array_name);
 319   1      	printf("SecPerClus:: %bx\r\n",Drive_values.SecPerClus);
 320   1      	RsvdSectorCount = read16(0x0E,array_name);
 321   1      	printf("RsvdSectorCount:: %x\r\n",RsvdSectorCount);
 322   1      	NumFATS = read8(0x10,array_name);
 323   1      	printf("NumFATS:: %bx\r\n",NumFATS);
 324   1      	RootEntryCnt = read16(0x11,array_name);
 325   1      	printf("RootEntryCnt:: %x\r\n",RootEntryCnt);
 326   1      	TotalSectors16 = read16(0x13,array_name);
 327   1      	printf("TotalSectors16:: %x\r\n",TotalSectors16);
 328   1      	FATsz16 = read16(0x16,array_name);
 329   1      	printf("FATsz16:: %x\r\n",FATsz16);
 330   1      	TotalSectors32 = read32(0x20,array_name);
 331   1      	printf("TotalSectors32:: %lx\r\n",TotalSectors32);
 332   1      	FATsz32 = read32(0x24,array_name);
 333   1      	printf("FATsz32:: %lx\r\n",FATsz32);
 334   1      	RootCluster = read32(0x2C, array_name);
 335   1      	printf("RootCluster:: %lx\r\n",RootCluster);
 336   1      	Drive_values.StartofFAT = RsvdSectorCount + RelativeSectors;
 337   1      	printf("StartofFAT:: %lx\r\n",Drive_values.StartofFAT);
 338   1      	Drive_values.RootDirSecs = ((RootEntryCnt*32) + (Drive_values.BytesPerSec-1))/Drive_values.BytesPerSec;
 339   1      	printf("RootDirSecs:: %lx\r\n",Drive_values.RootDirSecs);
 340   1      	Drive_values.FirstDataSec = RsvdSectorCount + (NumFATS*FATsz32) + Drive_values.RootDirSecs + RelativeSect
             -ors;
 341   1      	printf("FirstDataSec:: %lx\r\n",Drive_values.FirstDataSec);
 342   1      	Drive_values.FirstRootDirSec = ((RootCluster-2)*Drive_values.SecPerClus)+Drive_values.FirstDataSec;
 343   1      	printf("FirstRootDirSec:: %lx\r\n",Drive_values.FirstRootDirSec);
 344   1      	Drive_values.FATtype = FAT32;
 345   1      	Drive_values.FATshift = FAT32_shift;
 346   1      	// TODO: Determine FAT type
 347   1      	// if FAT16 is detected return error_flag\
 348   1      
 349   1      	//Print Directory
 350   1      	Print_Directory(Drive_values.FirstRootDirSec, array_name);
 351   1      	return error_flag;
 352   1      }
*** WARNING C280 IN LINE 276 OF .\DIRECTORY_FUNCTIONS_STRUCT.C: 'i': unreferenced local variable
 353          
 354          uint32_t First_Sector (uint32_t Cluster_num)
 355          {
 356   1          uint32_t FirstSecCluster;
 357   1          if(Cluster_num==0)
 358   1          {
 359   2              FirstSecCluster = Drive_values.FirstRootDirSec;
 360   2          }
 361   1          else
 362   1          {
 363   2              FirstSecCluster = ((Cluster_num-2)*Drive_values.SecPerClus)+Drive_values.FirstDataSec;
C51 COMPILER V6.02  DIRECTORY_FUNCTIONS_STRUCT                                             11/12/2019 13:08:19 PAGE 7   

 364   2          }
 365   1          return FirstSecCluster;
 366   1      }
 367          
 368          uint32_t Find_Next_Clus(uint32_t Cluster_num, uint8_t xdata * array_name)
 369          {
 370   1          uint32_t return_clus;
 371   1          uint32_t FATOffset = Cluster_num*4;
 372   1          uint32_t ThisFATSecNum = Drive_values.StartofFAT + (FATOffset/Drive_values.BytesPerSec);
 373   1      
 374   1          Read_Sector(ThisFATSecNum,Drive_values.BytesPerSec, array_name);
 375   1          FATOffset = (FATOffset % Drive_values.BytesPerSec);
 376   1          return_clus = (read32(FATOffset,array_name)&0x0FFFFFFF);
 377   1          return return_clus;
 378   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1831    ----
   CONSTANT SIZE    =    464    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      86
   IDATA SIZE       =     22    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
